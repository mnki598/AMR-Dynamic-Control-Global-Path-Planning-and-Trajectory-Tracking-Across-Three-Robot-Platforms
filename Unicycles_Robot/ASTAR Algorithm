%% unicycle_astar_final.m
% Author: Mayank Pandey
% Date: 2025
% A* (grid) + collision-free smoothing +Tracking using pure pursuit
% Self-contained, no special toolboxes required.
clear; close all; clc;

%% ---------------- USER PARAMETERS ----------------
grid_rows = 80; grid_cols = 80;   % grid cells (must be >6x6)
map_scale = 0.15;                 % meters per grid cell
world_w = grid_cols * map_scale;
world_h = grid_rows * map_scale;
inflation_radius = 0.25;          % robot radius for inflation (m)

% Start / Goal (world coordinates in meters)
start_world = [1.0, 1.0, 0.0];
goal_world  = [9.0, 7.0, 0.0];

allow_diagonal = true;

controller_type = 'pure_pursuit'; % 'pure_pursuit'
lookahead = 0.6;                  % pure pursuit lookahead (m)
v_nom = 0.5;                      % nominal forward speed (m/s)
max_v = 1.0; max_omega = 2.5;     % actuator limits
K_rho = 1.2; K_alpha = 6.0; K_beta = -1.0; % pose-feedback gains

dt = 0.05; Tsim = 200;
goal_tol = 0.08; goal_heading_tol = 0.08;

%% ---------------- BUILD OBSTACLES ----------------
% polygon list (each is 2xN matrix: [x; y])
polys = {
    [2.0 3.2 3.8 2.6; 1.6 1.6 2.6 3.0], ...
    [4.8 5.4 6.2 5.8 4.8; 4.0 4.6 4.2 3.4 4.0]
    };

% circles: rows [x, y, radius]
circles = [
    6.6, 1.8, 0.6;
    7.8, 3.0, 0.6;
    6.6, 6.8, 0.6
    ];

% Build grid centers
[Xg, Yg] = meshgrid(((0:grid_cols-1)+0.5)*map_scale, ((0:grid_rows-1)+0.5)*map_scale);
occ = false(grid_rows, grid_cols);

% Rasterize polygons
for p = 1:numel(polys)
    P = polys{p};
    xv = P(1,:)'; yv = P(2,:)';
    in = inpolygon(Xg, Yg, xv, yv);
    occ = occ | in;
end

% Rasterize circles
for c = 1:size(circles,1)
    cx = circles(c,1); cy = circles(c,2); cr = circles(c,3);
    in = ((Xg - cx).^2 + (Yg - cy).^2) <= cr^2;
    occ = occ | in;
end

% Inflate obstacles using convolution with disk kernel (no toolbox)
inflation_cells = max(1, ceil(inflation_radius / map_scale));
k = 2*inflation_cells+1;
[Xk, Yk] = meshgrid(1:k,1:k);
center = (k+1)/2;
disk_mask = ((Xk-center).^2 + (Yk-center).^2) <= inflation_cells^2;
conv_res = conv2(double(occ), double(disk_mask), 'same');
occ_infl = conv_res > 0;  % boolean inflated occupancy

%% ---------------- HELPER CONVERSIONS ----------------
% world(x,y) -> grid (row, col)
world2grid = @(x,y) deal( ...
    max(1, min(grid_rows, round(y / map_scale + 0.5))), ...
    max(1, min(grid_cols, round(x / map_scale + 0.5))) );

% grid (row, col) -> world (x,y) center
grid2world = @(r,c) deal( ...
    (c - 0.5) * map_scale, ...
    (r - 0.5) * map_scale );

wrapang = @(a) atan2(sin(a), cos(a));

% quick check start/goal
[sr, sc] = world2grid(start_world(1), start_world(2));
[gr, gc] = world2grid(goal_world(1), goal_world(2));
fprintf('Start world: (%.2f, %.2f) -> grid (r=%d,c=%d)\n', start_world(1), start_world(2), sr, sc);
fprintf('Goal  world: (%.2f, %.2f) -> grid (r=%d,c=%d)\n', goal_world(1), goal_world(2), gr, gc);

if occ_infl(sr,sc)
    error('Start is inside inflated obstacle. Move start.');
end
if occ_infl(gr,gc)
    error('Goal is inside inflated obstacle. Move goal.');
end

%% ---------------- PLOT ENVIRONMENT ----------------
figure('Name','Environment','Units','normalized','Position',[0.02 0.05 0.42 0.7]);
% Plot inflated obstacles as black points
[row_occ, col_occ] = find(occ_infl);
plot_x = (col_occ - 0.5) * map_scale;
plot_y = (row_occ - 0.5) * map_scale;
scatter(plot_x, plot_y, 10, 'k', 'filled'); hold on;
% Plot polygon outlines and circles
for p=1:numel(polys)
    P = polys{p}; plot(P(1,:), P(2,:), 'r-', 'LineWidth', 1.6);
end
for c=1:size(circles,1)
    viscircles(circles(c,1:2), circles(c,3), 'Color','r', 'LineWidth', 1);
end
plot(start_world(1), start_world(2), 'go','MarkerFaceColor','g','MarkerSize',10);
plot(goal_world(1), goal_world(2), 'ro','MarkerFaceColor','r','MarkerSize',10);
axis equal; xlim([0 world_w]); ylim([0 world_h]); grid on;
xlabel('X (m)'); ylabel('Y (m)'); title('Environment (inflated obstacles)');

%% ---------------- A* (grid) ----------------
start_idx = sub2ind([grid_rows, grid_cols], sr, sc);
goal_idx  = sub2ind([grid_rows, grid_cols], gr, gc);

if allow_diagonal
    nbrs = [ -1 0; 1 0; 0 -1; 0 1; -1 -1; -1 1; 1 -1; 1 1 ];
    costs = [1,1,1,1,sqrt(2),sqrt(2),sqrt(2),sqrt(2)];
else
    nbrs = [ -1 0; 1 0; 0 -1; 0 1 ];
    costs = [1,1,1,1];
end

N = grid_rows * grid_cols;
[rows_all, cols_all] = ind2sub([grid_rows, grid_cols], 1:N);

g_score = inf(N,1);
f_score = inf(N,1);
came_from = zeros(N,1);
open_set = false(N,1);
in_open_list = false(N,1);

g_score(start_idx) = 0;
heuristic = @(idx) sqrt( ((cols_all(idx)-gc)*map_scale).^2 + ((rows_all(idx)-gr)*map_scale).^2 );
f_score(start_idx) = heuristic(start_idx);
open_set(start_idx) = true; in_open_list(start_idx) = true;

nodes_expanded = 0;
tic;
while true
    open_idx = find(open_set);
    if isempty(open_idx)
        break;
    end
    [~,mi] = min(f_score(open_idx));
    current = open_idx(mi);
    open_set(current) = false;
    nodes_expanded = nodes_expanded + 1;
    if current == goal_idx
        break;
    end
    [cr, cc] = ind2sub([grid_rows, grid_cols], current);
    for ni = 1:size(nbrs,1)
        nr = cr + nbrs(ni,1);
        nc = cc + nbrs(ni,2);
        if nr < 1 || nr > grid_rows || nc < 1 || nc > grid_cols
            continue;
        end
        nid = sub2ind([grid_rows, grid_cols], nr, nc);
        if occ_infl(nr,nc)
            continue;
        end
        tentative_g = g_score(current) + costs(ni)*map_scale;
        if tentative_g < g_score(nid)
            came_from(nid) = current;
            g_score(nid) = tentative_g;
            f_score(nid) = tentative_g + heuristic(nid);
            if ~in_open_list(nid)
                open_set(nid) = true;
                in_open_list(nid) = true;
            end
        end
    end
end
elapsed = toc;
if came_from(goal_idx) == 0
    error('A*: no path found (nodes expanded: %d)', nodes_expanded);
end
fprintf('A* finished: nodes_expanded=%d, elapsed=%.3fs\n', nodes_expanded, elapsed);

%% ---------------- Reconstruct path (grid -> world) ----------------
path_idx = goal_idx;
while path_idx(end) ~= start_idx
    path_idx(end+1) = came_from(path_idx(end)); %#ok<SAGROW>
end
path_idx = fliplr(path_idx);
[path_r, path_c] = ind2sub([grid_rows, grid_cols], path_idx);

path_world = zeros(length(path_r),3);
for i=1:length(path_r)
    [wx, wy] = grid2world(path_r(i), path_c(i));
    path_world(i,1) = wx;
    path_world(i,2) = wy;
end
for i=1:size(path_world,1)-1
    dx = path_world(i+1,1) - path_world(i,1);
    dy = path_world(i+1,2) - path_world(i,2);
    path_world(i,3) = atan2(dy,dx);
end
path_world(end,3) = path_world(end-1,3);

plot(path_world(:,1), path_world(:,2), 'b.-','LineWidth',1.0,'MarkerSize',10);

%% ---------------- Collision-free shortcut smoothing ----------------
% segment_free uses world2grid (function handle) and map_scale
segment_free = @(p1, p2, map_scale_local, w2g) local_segment_free(p1, p2, map_scale_local, w2g, occ_infl, grid_rows, grid_cols);

sm = path_world(:,1:2);
% random shortcut attempts
for iter = 1:600
    if size(sm,1) <= 2, break; end
    i = randi([1, size(sm,1)-1]);
    j = randi([i+1, size(sm,1)]);
    if j <= i+1, continue; end
    if segment_free(sm(i,:), sm(j,:), map_scale, world2grid)
        sm = [ sm(1:i,:); sm(j,:); sm(j+1:end,:) ];
    end
end

% upsample by arclength with cubic interpolation
s = [0; cumsum( sqrt(sum(diff(sm).^2,2)) )];
if s(end) < 1e-6, error('Smoothed path too short'); end
si = linspace(0, s(end), max(200, ceil(s(end)/0.03)));
xsi = interp1(s, sm(:,1), si, 'pchip');
ysi = interp1(s, sm(:,2), si, 'pchip');
thetai = atan2([ysi(2:end) ysi(end)] - [ysi(1) ysi(1:end-1)], [xsi(2:end) xsi(end)] - [xsi(1) xsi(1:end-1)]);
thetai = wrapang(thetai);
ref_traj = [xsi(:), ysi(:), thetai(:)];

writetable(table(ref_traj(:,1),ref_traj(:,2),ref_traj(:,3), 'VariableNames',{'x','y','theta'}), 'planned_path.csv');
fprintf('Planned path saved to planned_path.csv (N=%d)\n', size(ref_traj,1));

plot(xsi, ysi, 'm-', 'LineWidth', 1.6);

%% ---------------- UNICYCLE TRACKING ----------------
% initial perturbed pose
x = start_world(1) - 0.25; y = start_world(2) + 0.18; th = start_world(3) + 0.2;
state = [x; y; th];

max_steps = ceil(Tsim/dt);
hist = zeros(max_steps,3);
time_log = zeros(max_steps,1);
errors = zeros(max_steps,2);
step = 0;
t_sim = 0;

closest_ref_idx = @(xq,yq) find( min( (ref_traj(:,1) - xq).^2 + (ref_traj(:,2) - yq).^2 ) == ((ref_traj(:,1) - xq).^2 + (ref_traj(:,2) - yq).^2), 1 );

for k = 1:max_steps
    step = step + 1;
    hist(step,:) = state';
    time_log(step) = t_sim;
    
    iclose = closest_ref_idx(state(1), state(2));
    dx = ref_traj(iclose,1) - state(1);
    dy = ref_traj(iclose,2) - state(2);
    cross_track = -(sin(state(3))*dx - cos(state(3))*dy);
    heading_err = wrapang(ref_traj(iclose,3) - state(3));
    errors(step,:) = [cross_track, heading_err];
    
    if iclose >= size(ref_traj,1)
        if norm([ref_traj(end,1)-state(1), ref_traj(end,2)-state(2)]) < goal_tol && abs(wrapang(ref_traj(end,3)-state(3))) < goal_heading_tol
            fprintf('Reached goal at t=%.2f s, steps=%d\n', t_sim, k);
            break;
        end
    end
    
    % controller selection
    if strcmp(controller_type,'pure_pursuit')
        % find lookahead index
        saccum = 0; idxL = iclose;
        for jj = iclose+1:size(ref_traj,1)
            saccum = saccum + norm(ref_traj(jj,1:2) - ref_traj(jj-1,1:2));
            if saccum >= lookahead
                idxL = jj; break;
            end
        end
        gx = ref_traj(min(idxL,end),1); gy = ref_traj(min(idxL,end),2);
        dxg = gx - state(1); dyg = gy - state(2);
        xg_r = cos(state(3))*dxg + sin(state(3))*dyg;
        yg_r = -sin(state(3))*dxg + cos(state(3))*dyg;
        if abs(xg_r) < 1e-9
            kappa = 0;
        else
            kappa = 2*yg_r / (lookahead^2);
        end
        v = v_nom;
        omega = v * kappa;
    else
        rho = sqrt(dx^2 + dy^2);
        alpha = wrapang( atan2(dy,dx) - state(3) );
        beta  = wrapang( wrapang(ref_traj(iclose,3) - state(3)) - alpha );
        v = K_rho * rho;
        omega = K_alpha * alpha + K_beta * beta;
        v = sign(v) * min(abs(v), max_v);
    end
    
    % saturate
    v = max(-max_v, min(max_v, v));
    omega = max(-max_omega, min(max_omega, omega));
    
    % integrate unicycle
    x = state(1); y = state(2); th = state(3);
    x = x + v * cos(th) * dt;
    y = y + v * sin(th) * dt;
    th = wrapang(th + omega * dt);
    state = [x; y; th];
    
    t_sim = t_sim + dt;
    
    % live plotting occasionally
    if mod(k,4) == 0
        figure(1); clf; hold on;
        scatter(plot_x, plot_y, 8, 'k', 'filled');
        for p = 1:numel(polys)
            P = polys{p}; plot(P(1,:), P(2,:), 'r-', 'LineWidth', 1.6);
        end
        for c = 1:size(circles,1); viscircles(circles(c,1:2), circles(c,3),'Color','r'); end
        plot(path_world(:,1), path_world(:,2), 'b.-','LineWidth',1.0);
        plot(xsi, ysi, 'm-','LineWidth',1.6);
        plot(hist(1:step,1), hist(1:step,2), '-g','LineWidth',1.4);
        plot(state(1), state(2), 'ko','MarkerFaceColor','k');
        plot(start_world(1), start_world(2), 'go','MarkerFaceColor','g');
        plot(goal_world(1), goal_world(2), 'ro','MarkerFaceColor','r');
        axis equal; xlim([0 world_w]); ylim([0 world_h]); grid on;
        title(sprintf('A* + Tracking | t=%.2f s', t_sim));
        drawnow;
        hold off;
    end
end

% Trim logs
hist = hist(1:step,:);
time_log = time_log(1:step);
errors = errors(1:step,:);

% performance
cross_rmse = sqrt(mean(errors(:,1).^2));
heading_rmse = sqrt(mean(errors(:,2).^2));
fprintf('Simulation finished. Sim time = %.2f s, steps = %d\n', t_sim, step);
fprintf('Cross-track RMSE = %.4f m, Heading RMSE = %.4f rad\n', cross_rmse, heading_rmse);

% final plots
figure('Name','Final Results','Units','normalized','Position',[0.45 0.05 0.5 0.8]);
subplot(2,1,1);
plot(xsi, ysi, 'm-','LineWidth',1.6); hold on;
plot(hist(:,1), hist(:,2), '-g','LineWidth',1.4);
plot(start_world(1), start_world(2), 'go','MarkerFaceColor','g');
plot(goal_world(1), goal_world(2), 'ro','MarkerFaceColor','r');
axis equal; grid on; xlabel('X (m)'); ylabel('Y (m)');
title(sprintf('Tracking result (controller=%s)', controller_type));
legend('Smoothed reference','Robot path','Start','Goal','Location','best');

subplot(2,2,3);
plot(time_log, errors(:,1)); xlabel('Time (s)'); ylabel('Cross-track (m)'); grid on;
subplot(2,2,4);
plot(time_log, errors(:,2)); xlabel('Time (s)'); ylabel('Heading err (rad)'); grid on;

save('astar_unicycle_sim_results_final.mat','hist','time_log','errors','ref_traj','path_world','xsi','ysi');

fprintf('Saved results to astar_unicycle_sim_results_final.mat\n');

%% ---------------- Local helper function ----------------
function ok = local_segment_free(p1, p2, map_scale_local, w2g, occ_infl_local, grid_rows_local, grid_cols_local)
    L = hypot(p2(1)-p1(1), p2(2)-p1(2));
    Ncheck = max(ceil(L / (map_scale_local*0.3)), 10);
    xs = linspace(p1(1), p2(1), Ncheck);
    ys = linspace(p1(2), p2(2), Ncheck);
    ok = true;
    for kk = 1:Ncheck
        [rr, cc] = w2g(xs(kk), ys(kk));
        rr = max(1, min(grid_rows_local, rr));
        cc = max(1, min(grid_cols_local, cc));
        if occ_infl_local(rr, cc)
            ok = false;
            return;
        end
    end
end

