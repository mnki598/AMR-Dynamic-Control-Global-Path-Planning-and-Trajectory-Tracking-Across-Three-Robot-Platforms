% File: Mecanum_wheel Recorded Trajectory Tracking
% Description: Four Mecanum wheel dynamics and PD tracking controller
% Author: Mayank Pandey
% Date: 2025
% Note: Public demonstration version. Full implementation private.

#!/usr/bin/env python3
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.interpolate import make_interp_spline
from scipy.signal import butter, filtfilt

# ============================
# CONTROL GAINS (Tuned for stability)
# ============================
K1 = np.diag([30.0, 30.0, 4.0])   # Position/orientation gains
K2 = np.diag([15.0, 15.0, 2.0])   # Velocity gains

# ============================
# ROBOT GEOMETRY (MECANUM)
# ============================
L1, L2, r = 0.002687, 0.075, 0.002456
Iz, Im, m = 0.07620822, 0.00192, 1.185
a = 1 / (L1 + L2)

# Inertia and mass terms
A = (Iz * r**2) / (16 * (L1 + L2)**2)
B = (m * r**2) / 8

# Wheel inertia matrix M
M = np.array([
    [A + B + Im, -A,          A,          B - A],
    [-A,         A + B + Im, B - A,      A],
    [A,          B - A,      A + B + Im, -A],
    [B - A,      A,          -A,         A + B + Im]
])

# Jacobian: body velocity → wheel speeds
J = (r / 4) * np.array([
    [-1,  1, -1,  1],
    [ 1,  1,  1,  1],
    [ a, -a, -a,  a]
])

# Pseudo-inverse: wheel speeds → body velocity
J_p = (1 / r) * np.array([
    [-1,  1,  1/a],
    [ 1,  1, -1/a],
    [-1,  1, -1/a],
    [ 1,  1,  1/a]
])

# Fix lateral axis sign
J[1, :] *= -1
J_p[:, 1] *= -1

# Damping matrix in wheel space (realistic values)
D_wheel = np.diag([0.001, 0.001, 0.001, 0.001])  # N·m·s

# Body damping term: F @ nu = damping force in body frame
F = ....

# Adding small body viscous damping 
F_body = np.diag([0.08, 0.08, 0.04])
F += F_body  # Combine

# ============================
# SIMULATION SETTINGS
# ============================
dt = 0.002
MAX_ACC = 2.0
MAX_VEL = 0.4

# ============================
# LOAD AND SMOOTH RECORDED TRAJECTORY
# ============================
filename = "C:/Users/netra/Downloads/trajectory_processed.csv"
df = pd.read_csv(filename)

t_des = df["time"].values
x_d = df["x"].values
y_d = df["y"].values
yaw_d = df.get("yaw", df.get("theta")).values
vx_d = df["vx"].values
vy_d = df["vy"].values
wz_d = df["wz"].values

# Optional: ax, ay, az — but we will NOT use them
# ax_d = df["ax"].values if "ax" in df else np.zeros_like(t_des)
# ay_d = df["ay"].values if "ay" in df else np.zeros_like(t_des)
# az_d = df["az"].values if "az" in df else np.zeros_like(t_des)

# ============================
# SMOOTH INTERPOLATION FUNCTION
# ============================
def smooth_interp(t, y, k=3, cutoff=5.0):
    """Butterworth filter + spline interpolation"""
    nyq = 0.5 / dt
    normal_cutoff = cutoff / nyq
    b, a = butter(2, normal_cutoff, btype='low')
    y_filt = filtfilt(b, a, y)
    spl = make_interp_spline(t, y_filt, k=k, bc_type='natural')
    return spl

# Create smooth interpolators
xd_f   = smooth_interp(t_des, x_d,   cutoff=10.0)
yd_f   = smooth_interp(t_des, y_d,   cutoff=10.0)
yaw_f  = smooth_interp(t_des, yaw_d, cutoff=3.0)   # Yaw: lower cutoff

vxd_f  = smooth_interp(t_des, vx_d,  cutoff=8.0)
vyd_f  = smooth_interp(t_des, vy_d,  cutoff=8.0)
wzd_f  = smooth_interp(t_des, wz_d,  cutoff=4.0)

# Optional: smooth acceleration via derivative of velocity splines
def deriv_interp(spline):
    return spline.derivative()

axd_f = deriv_interp(vxd_f)
ayd_f = deriv_interp(vyd_f)
azd_f = deriv_interp(wzd_f)

T = t_des[-1]
steps = int(T / dt) + 1
t = np.linspace(0, T, steps)

# ============================
# SIMULATION LOOP
# ============================
eta = np.array([x_d[0], y_d[0], yaw_d[0]])  # Start at initial pose
nu = np.zeros(3)

eta_log, etad_log = [], []
nu_log, nud_log = [], []

for k in range(steps):
    t_now = t[k]

    # Desired state (smooth)
    etad = np.array([xd_f(t_now), yd_f(t_now), yaw_f(t_now)])
    etad_dot_raw = np.array([vxd_f(t_now), vyd_f(t_now), wzd_f(t_now)])
    
    # Clip desired velocity to robot limits
    etad_dot = np.clip(etad_dot_raw, -MAX_VEL, MAX_VEL)

    # Desired acceleration (smooth derivative) — optional, used only if needed
    # etad_ddot = np.array([axd_f(t_now), ayd_f(t_now), azd_f(t_now)])

    theta = eta[2]
    c, s = np.cos(theta), np.sin(theta)
    R = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])
    R_dot = np.array([[-s*nu[2], -c*nu[2], 0],
                      [ c*nu[2], -s*nu[2], 0],
                      [0, 0, 0]])

    eta_dot = R @ nu

    # --- PD Control Law ---  
    gamma1 = ...     
    phiz = ....
    gamma2 = ...

    # Feedforward: only velocity terms + derivative of gamma1
    # NO etad_ddot (too noisy from real data)
    phidot = ....

    # Control input (body acceleration)
    u = ....

    # Clip acceleration
    u = np.clip(u, -MAX_ACC, MAX_ACC)

    # Integrate velocity
    nu += u * dt
    nu = np.clip(nu, -MAX_VEL, MAX_VEL)
    # NO artificial damping: nu *= 0.97 → removed

    # Integrate pose
    eta += eta_dot * dt
    eta[2] = np.arctan2(np.sin(eta[2]), np.cos(eta[2]))

    # Logging
    eta_log.append(eta.copy())
    etad_log.append(etad.copy())
    nu_log.append(nu.copy())
    nud_log.append(etad_dot.copy())

# Convert to arrays
eta_log = np.array(eta_log)
etad_log = np.array(etad_log)
nu_log = np.array(nu_log)
nud_log = np.array(nud_log)

# ============================
# PLOTTING RESULTS
# ============================
plt.figure(figsize=(12, 10))

# 1. Trajectory in XY
plt.subplot(3, 1, 1)
plt.plot(etad_log[:, 0], etad_log[:, 1], 'r--', label='Desired', linewidth=1.5)
plt.plot(eta_log[:, 0], eta_log[:, 1], 'b-', label='Simulated', linewidth=1.5)
plt.xlabel('X [m]')
plt.ylabel('Y [m]')
plt.title('Mecanum PD Tracking – Recorded Trajectory (Smoothed & Stable)')
plt.legend()
plt.grid(True)
plt.axis('equal')

# 2. Tracking Errors
plt.subplot(3, 1, 2)
err_x = etad_log[:, 0] - eta_log[:, 0]
err_y = etad_log[:, 1] - eta_log[:, 1]
err_yaw = np.unwrap(etad_log[:, 2] - eta_log[:, 2])

plt.plot(t, err_x, label='X error', color='cyan')
plt.plot(t, err_y, label='Y error', color='orange')
plt.plot(t, err_yaw, label='Yaw error', color='green')
plt.xlabel('Time [s]')
plt.ylabel('Error [m / rad]')
plt.legend()
plt.grid(True)

# 3. Velocity Tracking
plt.subplot(3, 1, 3)
plt.plot(t, nud_log[:, 0], 'r--', label='vx des', alpha=0.7)
plt.plot(t, nu_log[:, 0], 'r-', label='vx act')
plt.plot(t, nud_log[:, 1], 'g--', label='vy des', alpha=0.7)
plt.plot(t, nu_log[:, 1], 'g-', label='vy act')
plt.plot(t, nud_log[:, 2], 'b--', label='wz des', alpha=0.7)
plt.plot(t, nu_log[:, 2], 'b-', label='wz act')
plt.xlabel('Time [s]')
plt.ylabel('Velocity [m/s, rad/s]')
plt.legend()
plt.grid(True)
plt.ylim(-0.5, 0.5)

plt.tight_layout()
plt.show()

# ============================
# PRINT FINAL ERROR STATS
# ============================
print("\n=== FINAL TRACKING ERROR ===")
print(f"RMS X error:     {np.sqrt(np.mean(err_x**2)):.4f} m")
print(f"RMS Y error:     {np.sqrt(np.mean(err_y**2)):.4f} m")
print(f"RMS Yaw error:   {np.sqrt(np.mean(err_yaw**2)):.4f} rad")
print(f"Max |X| error:   {np.max(np.abs(err_x)):.4f} m")
print(f"Max |Y| error:   {np.max(np.abs(err_y)):.4f} m")
print(f"Max |Yaw| error: {np.max(np.abs(err_yaw)):.4f} rad")

# ============================
# SAVE PLOT & ANIMATION
# ============================
import matplotlib.animation as animation
from matplotlib.patches import Rectangle, Arrow
import os

# --- 1. Save static figure ---
plot_filename_png = "mecanum_tracking_result.png"
plot_filename_pdf = "mecanum_tracking_result.pdf"

plt.figure(figsize=(12, 10))  # Re-create figure for saving (clean)
# Re-plot everything (same as above)
plt.subplot(3, 1, 1)
plt.plot(etad_log[:, 0], etad_log[:, 1], 'r--', label='Desired', linewidth=1.5)
plt.plot(eta_log[:, 0], eta_log[:, 1], 'b-', label='Simulated', linewidth=1.5)
plt.xlabel('X [m]'); plt.ylabel('Y [m]')
plt.title('Mecanum PD Tracking – Recorded Trajectory')
plt.legend(); plt.grid(True); plt.axis('equal')

plt.subplot(3, 1, 2)
plt.plot(t, err_x, label='X error', color='cyan')
plt.plot(t, err_y, label='Y error', color='orange')
plt.plot(t, err_yaw, label='Yaw error', color='green')
plt.xlabel('Time [s]'); plt.ylabel('Error [m / rad]')
plt.legend(); plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(t, nud_log[:, 0], 'r--', label='vx des', alpha=0.7)
plt.plot(t, nu_log[:, 0], 'r-', label='vx act')
plt.plot(t, nud_log[:, 1], 'g--', label='vy des', alpha=0.7)
plt.plot(t, nu_log[:, 1], 'g-', label='vy act')
plt.plot(t, nud_log[:, 2], 'b--', label='wz des', alpha=0.7)
plt.plot(t, nu_log[:, 2], 'b-', label='wz act')
plt.xlabel('Time [s]'); plt.ylabel('Velocity [m/s, rad/s]')
plt.legend(); plt.grid(True)
plt.ylim(-0.5, 0.5)

plt.tight_layout()

# Save high-quality versions
plt.savefig(plot_filename_png, dpi=300, bbox_inches='tight')
plt.savefig(plot_filename_pdf, bbox_inches='tight')
print(f"Static plot saved: {plot_filename_png}, {plot_filename_pdf}")

# --- 2. Create and save animation ---
anim_filename_mp4 = "mecanum_tracking_animation.mp4"
anim_filename_gif = "mecanum_tracking_animation.gif"

fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xlim(min(np.min(eta_log[:,0]), np.min(etad_log[:,0])) - 0.5,
            max(np.max(eta_log[:,0]), np.max(etad_log[:,0])) + 0.5)
ax.set_ylim(min(np.min(eta_log[:,1]), np.min(etad_log[:,1])) - 0.5,
            max(np.max(eta_log[:,1]), np.max(etad_log[:,1])) + 0.5)
ax.set_xlabel('X [m]'); ax.set_ylabel('Y [m]')
ax.set_title('Mecanum Robot Trajectory Tracking')
ax.grid(True)
ax.set_aspect('equal')

# Plot full desired path
ax.plot(etad_log[:, 0], etad_log[:, 1], 'r--', label='Desired Path', alpha=0.6)
line_sim, = ax.plot([], [], 'b-', label='Simulated Path', linewidth=2)
point_des = ax.scatter([], [], c='red', s=60, label='Desired Pose', zorder=5)
point_sim = ax.scatter([], [], c='blue', s=60, label='Robot', zorder=5)

# Robot body (rectangle + direction arrow)
robot_width = 0.15
robot_length = 0.20
robot_body = Rectangle((0, 0), robot_length, robot_width, angle=0, 
                       facecolor='blue', edgecolor='black', alpha=0.6)
arrow = Arrow(0, 0, 0.08, 0, width=0.06, color='black')
ax.add_patch(robot_body)
ax.add_patch(arrow)

ax.legend()

def init():
    line_sim.set_data([], [])
    point_des.set_offsets(np.empty((0, 2)))
    point_sim.set_offsets(np.empty((0, 2)))
    robot_body.set_xy((0, 0))
    arrow.set_xy((0, 0))
    arrow._dx, arrow._dy = 0.08, 0
    return line_sim, point_des, point_sim, robot_body, arrow

def update(frame):
    # Update simulated path
    line_sim.set_data(eta_log[:frame, 0], eta_log[:frame, 1])
    
    # Current desired and simulated points
    point_des.set_offsets([etad_log[frame, 0], etad_log[frame, 1]])
    point_sim.set_offsets([eta_log[frame, 0], eta_log[frame, 1]])
    
    # Update robot rectangle and arrow
    x, y, theta = eta_log[frame, 0], eta_log[frame, 1], eta_log[frame, 2]
    theta_deg = np.degrees(theta)
    
    # Center of robot
    robot_body.set_xy((x - robot_length/2 * np.cos(theta) + robot_width/2 * np.sin(theta),
                       y - robot_length/2 * np.sin(theta) - robot_width/2 * np.cos(theta)))
    robot_body.angle = theta_deg
    
    # Arrow from center forward
    arrow.set_xy((x, y))
    arrow._dx = 0.08 * np.cos(theta)
    arrow._dy = 0.08 * np.sin(theta)
    
    return line_sim, point_des, point_sim, robot_body, arrow

# Sample every N frames for speed
frame_skip = max(1, len(t) // 1000)  # ~1000 frames max
frames = range(0, len(t), frame_skip)

ani = animation.FuncAnimation(fig, update, frames=frames,
                              init_func=init, blit=False, repeat=False)

# Save as MP4 (requires ffmpeg)
try:
    ani.save(anim_filename_mp4, writer='ffmpeg', fps=30, dpi=200, bitrate=1800)
    print(f"Animation saved: {anim_filename_mp4}")
except Exception as e:
    print(f"Failed to save MP4 (ffmpeg not available?): {e}")

# Save as GIF (fallback, slower)
try:
    ani.save(anim_filename_gif, writer='pillow', fps=20)
    print(f"Animation saved: {anim_filename_gif}")
except Exception as e:
    print(f"Failed to save GIF: {e}")

plt.close(fig)
print("All files saved!")
